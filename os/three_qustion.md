1. 你这个操作系统抢占式多任务的时间片是怎么调度是怎么样的？
ans：
    我这个系统抢占式多任务实现的比较简单，没有用哪些进程调度算法，也暂时没有实现优先级，仅仅是轮转。
    这里我们设置一个固定的时间片1秒
    #define CLINT_TIMEBASE_FREQ 10000000
    因为按照晶振的频率，10000000次/秒，每当一个时间片过去，client设备就会发出一次定时器中断。
    系统的trap_handle函数就会感觉中断码区执行相应的函数，
                    case 7:
                    uart_puts("timer interruption!\n");
                    timer_handler();
                    break;
    timer_handler()函数就会调用任务切换函数，切换当前任务
                    void timer_handler() 
                    {
                        _tick++;
                        printf("tick: %d\n", _tick);

                        timer_load(TIMER_INTERVAL);

                        schedule();
                    }

    schedule()会将当前任务的上下文保存到内存中，从内存中恢复将要执行的任务的上下文来达到任务的切换。
    任务的切换没有优先级，仅仅是总任务数组中取出下一个任务，如果是最后一个任务则切换成第一个任务。
                    	_current = (_current + 1) % _top;
	                    struct context *next = &(ctx_tasks[_current]);









2. 这个项目中你最中意的部分是哪里，中意的原因？
        抢占式多任务和命令行的实现，前者是因为在写这一模块时，算是对前面所有模块的综合应用。
        抢占式的多任务的任务切换是不依赖任务本身，需要一个第三者来调节，因此，我们必须事前保证
        中断和异常的实现。当任务的在运行时，通过外部的中断来强行改变当前的上下文。所以我们还要先实现
        任务的创建和上下文存储和恢复。
        另外，任务的切换需要稳定且持续的触发，为此，我们需要使用的硬件定时器和软件定时器。
        而再多任务的并发中我们将面临共享资源可能被不恰当的使用，我们需要锁来保证这些资源被安全使用。
        这个部分的实现横跨多个模块，写的时候有很大的成就感。
        命令行的实现让我能够与操作系统进行实时的交互和控制。我可以使用命令获取系统时间，通过命令在后台开启新的任务，通过clear命令清理屏幕上的输出。最重要的是，我可以通过命令在单任务和多任务之间实时切换，充分利用系统的资源和提高效率。这让我真正感受到这个操作系统不再是一个简单的玩具，而是一个真正功能完备的操作系统。


3. 开发这个项目过程中，遇到的最大的困难是什么？
ans： 
    每次修改代码或者新增功能时，这个系统经常会出现莫名其妙报错和异常。
    经常要查手册的异常码表，然而，即使是找到了是什么异常，也不知道是哪个步骤导致了。
    要打断点或打印日志。非常麻烦，很多时候就算知道导致报错的命令，也不知道为什么这里不能
    执行这个命令。该系统的中断和异常模块非常无力，在开发时，修复bug的方法经常要靠猜，
    搜索引擎也搜不出来解决方法。做系统和开发其他软件不同，你的运行的环境是独一无二的，
    如果相关的教程没有说明相关的问题，只能靠自己尝试，很多时候想不明白的点太多了，只能放弃。
    最好解决的方法就是换一种实现方法试试。
    



